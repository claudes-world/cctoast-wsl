#!/usr/bin/env node

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports, module) {
    var p2 = process || {};
    var argv = p2.argv || [];
    var env = p2.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p2.platform === "win32" || (p2.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module.exports = createColors();
    module.exports.createColors = createColors;
  }
});

// src/cli.ts
var import_picocolors = __toESM(require_picocolors(), 1);
import { Command } from "commander";
import process2 from "node:process";
import { readFileSync } from "node:fs";
import { join as join2 } from "node:path";
import { fileURLToPath } from "node:url";
import * as p from "@clack/prompts";

// src/dependencies.ts
import { exec } from "node:child_process";
import { promisify } from "node:util";
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";
import { homedir } from "node:os";
var execAsync = promisify(exec);
var DependencyChecker = class {
  // 24 hours
  constructor(_forceRefresh = false) {
    this._forceRefresh = _forceRefresh;
  }
  cacheDir = join(homedir(), ".cache", "cctoast-wsl");
  cacheFile = join(this.cacheDir, "checks.json");
  cacheTimeoutMs = 24 * 60 * 60 * 1e3;
  /**
   * Check all dependencies with caching
   */
  async checkAll() {
    const checks = [
      () => this.checkWSLEnvironment(),
      () => this.checkPowerShellAccess(),
      () => this.checkBurntToast(),
      () => this.checkJqBinary(),
      () => this.checkClaudeDirectory()
    ];
    const results = [];
    for (const check of checks) {
      try {
        const result = await this.runWithCache(check);
        results.push(result);
      } catch (error) {
        const errorResult = {
          name: "unknown",
          passed: false,
          fatal: true,
          message: `Check failed: ${error instanceof Error ? error.message : error}`,
          timestamp: Date.now()
        };
        results.push(errorResult);
      }
    }
    await this.saveCache(results);
    return results;
  }
  /**
   * Check WSL environment (fatal)
   */
  async checkWSLEnvironment() {
    const name = "wsl-environment";
    try {
      const procVersion = await readFile("/proc/version", "utf8");
      const isWSL1 = procVersion.includes("Microsoft");
      const isWSL2 = procVersion.includes("WSL2") || procVersion.includes("microsoft-standard");
      if (isWSL1 || isWSL2) {
        return {
          name,
          passed: true,
          fatal: true,
          message: `Detected ${isWSL2 ? "WSL2" : "WSL1"} environment`,
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "Not running in WSL environment",
          remedy: "Run inside Windows Subsystem for Linux (WSL)",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "Unable to detect WSL environment",
        remedy: "Ensure you are running inside WSL",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check PowerShell.exe accessibility (fatal)
   */
  async checkPowerShellAccess() {
    const name = "powershell-exe";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Write-Output test"',
        {
          timeout: 5e3
        }
      );
      if (stdout.trim() === "test") {
        return {
          name,
          passed: true,
          fatal: true,
          message: "PowerShell.exe accessible and functional",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "PowerShell.exe not responding correctly",
          remedy: "Add Windows PowerShell to PATH or check WSL interop settings",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "PowerShell.exe not accessible from PATH",
        remedy: 'Add Windows PowerShell to PATH: export PATH="$PATH:/mnt/c/Windows/System32/WindowsPowerShell/v1.0"',
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check BurntToast module (fatal, but auto-installable)
   */
  async checkBurntToast() {
    const name = "burnttoast-module";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Get-Module -ListAvailable -Name BurntToast | Select-Object Version"',
        { timeout: 1e4 }
      );
      if (stdout.trim() && !stdout.includes("No modules")) {
        const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
        const version = versionMatch ? versionMatch[1] : "unknown";
        return {
          name,
          passed: true,
          fatal: true,
          message: `BurntToast module installed (version ${version})`,
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "BurntToast PowerShell module not installed",
          remedy: "Install-Module BurntToast -Scope CurrentUser -Force",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "Unable to check BurntToast module availability",
        remedy: "Check PowerShell execution policy and install: Install-Module BurntToast -Scope CurrentUser -Force",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check PowerShell execution policy (warning only)
   */
  async checkExecutionPolicy() {
    const name = "execution-policy";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Get-ExecutionPolicy"',
        { timeout: 5e3 }
      );
      const policy = stdout.trim();
      const restrictivePolicies = ["Restricted", "AllSigned"];
      if (restrictivePolicies.includes(policy)) {
        return {
          name,
          passed: false,
          fatal: false,
          message: `PowerShell execution policy is restrictive: ${policy}`,
          remedy: "Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: true,
          fatal: false,
          message: `PowerShell execution policy: ${policy}`,
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "Unable to check PowerShell execution policy",
        remedy: "Check PowerShell access and consider setting: Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check jq binary availability (optional)
   */
  async checkJqBinary() {
    const name = "jq-binary";
    try {
      await execAsync("command -v jq", { timeout: 2e3 });
      return {
        name,
        passed: true,
        fatal: false,
        message: "jq binary available",
        timestamp: Date.now()
      };
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "jq binary not found",
        remedy: "Install jq: sudo apt-get install jq (Ubuntu/Debian) or brew install jq (macOS)",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check Claude directory exists (warning only)
   */
  async checkClaudeDirectory() {
    const name = "claude-directory";
    const globalClaudeDir = join(homedir(), ".claude");
    try {
      if (existsSync(globalClaudeDir)) {
        return {
          name,
          passed: true,
          fatal: false,
          message: "Claude directory exists",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: false,
          message: "Claude directory not found",
          remedy: "Install Claude Code first, or hooks will not function until Claude is installed",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "Unable to check Claude directory",
        remedy: "Ensure Claude Code is properly installed",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Run a check function with caching support
   */
  async runWithCache(checkFn) {
    if (!this._forceRefresh) {
      const cachedResult = await this.getCachedResult(checkFn.name);
      if (cachedResult && this.isCacheValid(cachedResult)) {
        return cachedResult;
      }
    }
    return await checkFn();
  }
  /**
   * Get cached result for a specific check
   */
  async getCachedResult(checkName) {
    try {
      if (!existsSync(this.cacheFile)) {
        return null;
      }
      const cacheData = JSON.parse(
        await readFile(this.cacheFile, "utf8")
      );
      return cacheData[checkName] || null;
    } catch {
      return null;
    }
  }
  /**
   * Check if cached result is still valid (within 24h)
   */
  isCacheValid(result) {
    const age = Date.now() - result.timestamp;
    return age < this.cacheTimeoutMs;
  }
  /**
   * Save check results to cache
   */
  async saveCache(results) {
    try {
      await mkdir(this.cacheDir, { recursive: true });
      let cacheData = {};
      if (existsSync(this.cacheFile)) {
        try {
          cacheData = JSON.parse(await readFile(this.cacheFile, "utf8"));
        } catch {
          cacheData = {};
        }
      }
      for (const result of results) {
        cacheData[result.name] = result;
      }
      const tempFile = `${this.cacheFile}.tmp`;
      await writeFile(tempFile, JSON.stringify(cacheData, null, 2));
      await execAsync(`mv "${tempFile}" "${this.cacheFile}"`);
    } catch (error) {
      console.warn("Failed to save dependency check cache:", error);
    }
  }
};

// src/cli.ts
import { stream } from "@clack/prompts";
var __dirname = fileURLToPath(new URL(".", import.meta.url));
var packagePath = join2(__dirname, "..", "package.json");
var packageJson = JSON.parse(readFileSync(packagePath, "utf8"));
var ExitCodes = {
  SUCCESS: 0,
  USER_ABORT: 1,
  DEPENDENCY_FAILURE: 2,
  IO_ERROR: 3
};
function initializeCLI() {
  const program = new Command();
  program.name("cctoast-wsl").description(
    "Secure, zero-admin utility for Windows toast notifications from WSL via Claude Code hooks"
  ).version(packageJson.version, "-v, --version", "Display version number");
  program.option("-g, --global", "Install for user to ~/.claude/... (default)").option("-l, --local", "Install for project to .claude/...").addHelpText(
    "after",
    "\nScope Options:\n  Only one of --global or --local can be specified"
  );
  program.option("--notification", "Include Notification hook (default)", true).option("--no-notification", "Exclude Notification hook").option("--stop", "Include Stop hook (default)", true).option("--no-stop", "Exclude Stop hook");
  program.option(
    "--sync",
    "When local, modify tracked settings.json instead of settings.local.json (not recommended for teams due to Windows-only nature of hooks)",
    false
  );
  program.option("-p, --print-instructions", "Show usage instructions and exit").option("--json", "Machine-readable JSON output", false).option("-n, --dry-run", "Preview changes without writing files").option(
    "-f, --force",
    "Bypass failed dependency checks (except BurntToast)"
  ).option("-q, --quiet", "Suppress interactive prompts for CI environments");
  program.option("--uninstall", "Remove cctoast-wsl installation");
  return program;
}
function validateFlags(options) {
  if (!options.global && !options.local) {
    options.global = true;
  }
  if (options.global && options.local) {
    console.error("Error: --global and --local flags cannot be used together");
    process2.exit(ExitCodes.USER_ABORT);
  }
  if (!options.notification && !options.stop) {
    console.error(
      "Error: At least one hook (--notification or --stop) must be enabled"
    );
    process2.exit(ExitCodes.USER_ABORT);
  }
  if (options.sync && !options.local) {
    console.error("Warning: --sync flag only applies to local installations");
  }
}
function handlePrintInstructions() {
  console.log(`
cctoast-wsl v${packageJson.version} - Usage Instructions

INSTALLATION:
  npx @claude/cctoast-wsl                    # Global install with defaults
  npx @claude/cctoast-wsl --local           # Local project install
  npx @claude/cctoast-wsl --dry-run         # Preview changes

EXAMPLES:
  npx @claude/cctoast-wsl --global --notification --stop
  npx @claude/cctoast-wsl --local --sync --no-stop
  npx @claude/cctoast-wsl --uninstall --global

HOOK USAGE:
  After installation, Claude Code will automatically trigger toast notifications:
  - Notification hook: Shows when Claude is waiting for input
  - Stop hook: Shows when Claude completes a task

MANUAL TESTING:
  ~/.claude/cctoast-wsl/show-toast.sh --notification-hook
  ~/.claude/cctoast-wsl/show-toast.sh --stop-hook

For complete documentation: https://github.com/claudes-world/cctoast-wsl
`);
  process2.exit(ExitCodes.SUCCESS);
}
function formatOutput(data, useJson) {
  if (useJson) {
    console.log(JSON.stringify(data, null, 2));
  } else {
    console.log("Installation completed successfully");
  }
}
function isInteractive() {
  return process2.stdin.isTTY && process2.stdout.isTTY;
}
function handleCancel() {
  p.cancel("Operation cancelled by user");
  process2.exit(ExitCodes.USER_ABORT);
}
async function runInteractiveMode() {
  p.intro("\u{1F35E} cctoast-wsl Installation");
  const scope = await p.select({
    message: "Choose installation scope:",
    options: [
      {
        value: "global",
        label: "Global",
        hint: "\u2605 Recommended - Install to ~/.claude/"
      },
      {
        value: "local",
        label: "Local",
        hint: "Install to current project .claude/"
      }
    ]
  });
  if (p.isCancel(scope)) {
    handleCancel();
  }
  const scopeValue = scope;
  const hooks = await p.multiselect({
    message: "Select hooks to enable:",
    options: [
      {
        value: "notification",
        label: "Notification hook",
        hint: "Shows toast when Claude is waiting for input"
      },
      {
        value: "stop",
        label: "Stop hook",
        hint: "Shows toast when Claude completes a task"
      }
    ],
    initialValues: ["notification", "stop"],
    required: true
  });
  if (p.isCancel(hooks)) {
    handleCancel();
  }
  let sync = false;
  if (scopeValue === "local") {
    const syncResult = await p.confirm({
      message: "Modify tracked settings.json instead of settings.local.json?",
      initialValue: false
    });
    if (p.isCancel(syncResult)) {
      handleCancel();
    }
    sync = syncResult;
  }
  const hooksList = hooks;
  const summary = [
    `Scope: ${scopeValue}`,
    `Hooks: ${hooksList.join(", ")}`,
    ...scopeValue === "local" ? [`Sync: ${sync ? "yes" : "no"}`] : []
  ];
  p.log.info(
    `Configuration summary:
${summary.map((item) => `  \u2022 ${item}`).join("\n")}`
  );
  let configExplanation = "";
  if (scopeValue === "global") {
    configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your global settings at ~/.claude/settings.json.
The cctoast-wsl tool will install the necessary scripts and configuration for Windows toast notifications, available to all WSL sessions for your user.`;
  } else if (scopeValue === "local") {
    if (sync) {
      configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your project's tracked settings at ./.claude/settings.json.
This will update the main project settings (recommended only if your team is Windows-only).`;
    } else {
      configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your local-only settings at ./.claude/settings.local.json.
This keeps Windows-specific configuration out of version control, ideal for cross-platform teams.`;
    }
    configExplanation += "\nThe cctoast-wsl tool will install the necessary scripts and configuration for toast notifications in this project.";
  }
  if (configExplanation) {
    p.log.message(configExplanation);
  }
  const proceed = await p.confirm({
    message: "Proceed with installation?",
    initialValue: true
  });
  if (p.isCancel(proceed) || !proceed) {
    handleCancel();
  }
  p.outro("Ready to install! \u{1F389}");
  return {
    global: scopeValue === "global",
    local: scopeValue === "local",
    notification: hooksList.includes("notification"),
    stop: hooksList.includes("stop"),
    sync,
    printInstructions: false,
    json: false,
    dryRun: false,
    force: false,
    quiet: false,
    uninstall: false
  };
}
function setupSignalHandlers() {
  process2.on("SIGINT", () => {
    p.cancel("\nOperation cancelled by user");
    process2.exit(ExitCodes.USER_ABORT);
  });
  process2.on("SIGTERM", () => {
    p.cancel("\nOperation terminated");
    process2.exit(ExitCodes.USER_ABORT);
  });
}
async function runDependencyChecks(options) {
  const checker = new DependencyChecker(options.force);
  const checkStream = async function* () {
    yield import_picocolors.default.cyan("\u23F3 Starting dependency checks...");
    const results = await checker.checkAll();
    for (const r of results) {
      if (r.passed) {
        yield import_picocolors.default.green(`\u2714 ${r.message}`);
      } else if (r.fatal) {
        yield import_picocolors.default.red(`\u2716 ${r.message}`);
      } else {
        yield import_picocolors.default.yellow(`\u26A0\uFE0F  ${r.message}`);
      }
    }
    yield import_picocolors.default.cyan("\u2705 All dependency checks complete!");
  }();
  stream.info(checkStream);
}
function hasExplicitFlags(argv) {
  const flagsToCheck = [
    "--global",
    "-g",
    "--local",
    "-l",
    "--no-notification",
    "--no-stop",
    "--sync",
    "--json",
    "--dry-run",
    "-n",
    "--force",
    "-f",
    "--quiet",
    "-q",
    "--uninstall"
  ];
  return flagsToCheck.some((flag) => argv.includes(flag));
}
async function main() {
  try {
    setupSignalHandlers();
    const program = initializeCLI();
    program.parse();
    let options = program.opts();
    if (options.printInstructions) {
      handlePrintInstructions();
      return;
    }
    const shouldUseInteractive = !options.quiet && isInteractive() && !hasExplicitFlags(process2.argv);
    if (shouldUseInteractive) {
      options = await runInteractiveMode();
    } else {
      validateFlags(options);
    }
    if (options.json) {
      const checker = new DependencyChecker(options.force);
      const depResults = await checker.checkAll();
      const result = {
        action: options.uninstall ? "uninstall" : "install",
        scope: options.local ? "local" : "global",
        hooks: {
          notification: options.notification,
          stop: options.stop
        },
        settings: {
          sync: options.sync,
          dryRun: options.dryRun,
          force: options.force,
          quiet: options.quiet
        },
        dependencies: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          results: depResults.map((r) => ({
            name: r.name,
            passed: r.passed,
            fatal: r.fatal,
            message: r.message,
            remedy: r.remedy
          })),
          summary: {
            total: depResults.length,
            passed: depResults.filter((r) => r.passed).length,
            failed: depResults.filter((r) => !r.passed).length,
            fatal: depResults.filter((r) => !r.passed && r.fatal).length,
            warnings: depResults.filter((r) => !r.passed && !r.fatal).length
          }
        }
      };
      console.log(JSON.stringify(result, null, 2));
      const fatalFailures = depResults.filter((r) => !r.passed && r.fatal);
      if (fatalFailures.length > 0 && !options.force) {
        process2.exit(ExitCodes.DEPENDENCY_FAILURE);
      }
    } else {
      await runDependencyChecks(options);
    }
    if (options.dryRun && !options.json) {
      console.log("\n\u{1F4CB} DRY RUN MODE - No files will be modified");
    }
    if (!options.json && !shouldUseInteractive) {
      const result = {
        action: options.uninstall ? "uninstall" : "install",
        scope: options.local ? "local" : "global",
        hooks: {
          notification: options.notification,
          stop: options.stop
        },
        settings: {
          sync: options.sync,
          dryRun: options.dryRun,
          force: options.force,
          quiet: options.quiet
        }
      };
      formatOutput(result, false);
      console.log(
        "\n\u{1F389} Dependency Management System implemented successfully!"
      );
      console.log("\u{1F4CB} Installation logic will be added in Milestone 4");
    }
  } catch (error) {
    console.error(
      "Unexpected error:",
      error instanceof Error ? error.message : error
    );
    process2.exit(ExitCodes.IO_ERROR);
  }
}
if (import.meta.url === `file://${process2.argv[1]}`) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    process2.exit(ExitCodes.IO_ERROR);
  });
}
export {
  ExitCodes,
  initializeCLI,
  main,
  validateFlags
};
//# sourceMappingURL=cctoast-wsl.map
