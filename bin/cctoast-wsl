#!/usr/bin/env node

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports, module) {
    var p2 = process || {};
    var argv = p2.argv || [];
    var env = p2.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p2.platform === "win32" || (p2.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module.exports = createColors();
    module.exports.createColors = createColors;
  }
});

// src/cli.ts
var import_picocolors = __toESM(require_picocolors(), 1);
import { Command } from "commander";
import process2 from "node:process";
import { readFileSync } from "node:fs";
import { join as join2 } from "node:path";
import { fileURLToPath } from "node:url";
import * as p from "@clack/prompts";

// src/dependencies.ts
import { exec } from "node:child_process";
import { promisify } from "node:util";
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";
import { homedir } from "node:os";
var execAsync = promisify(exec);
var DependencyChecker = class {
  // 24 hours
  constructor(_forceRefresh = false) {
    this._forceRefresh = _forceRefresh;
  }
  cacheDir = join(homedir(), ".cache", "cctoast-wsl");
  cacheFile = join(this.cacheDir, "checks.json");
  cacheTimeoutMs = 24 * 60 * 60 * 1e3;
  /**
   * Check all dependencies with caching
   */
  async checkAll() {
    const checks = [
      () => this.checkWSLEnvironment(),
      () => this.checkPowerShellAccess(),
      () => this.checkBurntToast(),
      () => this.checkJqBinary(),
      () => this.checkClaudeDirectory()
    ];
    const results = [];
    for (const check of checks) {
      try {
        const result = await this.runWithCache(check);
        results.push(result);
      } catch (error) {
        const errorResult = {
          name: "unknown",
          passed: false,
          fatal: true,
          message: `Check failed: ${error instanceof Error ? error.message : error}`,
          timestamp: Date.now()
        };
        results.push(errorResult);
      }
    }
    await this.saveCache(results);
    return results;
  }
  /**
   * Check WSL environment (fatal)
   */
  async checkWSLEnvironment() {
    const name = "wsl-environment";
    try {
      const procVersion = await readFile("/proc/version", "utf8");
      const isWSL1 = procVersion.includes("Microsoft");
      const isWSL2 = procVersion.includes("WSL2") || procVersion.includes("microsoft-standard");
      if (isWSL1 || isWSL2) {
        return {
          name,
          passed: true,
          fatal: true,
          message: `Detected ${isWSL2 ? "WSL2" : "WSL1"} environment`,
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "Not running in WSL environment",
          remedy: "Run inside Windows Subsystem for Linux (WSL)",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "Unable to detect WSL environment",
        remedy: "Ensure you are running inside WSL",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check PowerShell.exe accessibility (fatal)
   */
  async checkPowerShellAccess() {
    const name = "powershell-exe";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Write-Output test"',
        {
          timeout: 5e3
        }
      );
      if (stdout.trim() === "test") {
        return {
          name,
          passed: true,
          fatal: true,
          message: "PowerShell.exe accessible and functional",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "PowerShell.exe not responding correctly",
          remedy: "Add Windows PowerShell to PATH or check WSL interop settings",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "PowerShell.exe not accessible from PATH",
        remedy: 'Add Windows PowerShell to PATH: export PATH="$PATH:/mnt/c/Windows/System32/WindowsPowerShell/v1.0"',
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check BurntToast module (fatal, but auto-installable)
   */
  async checkBurntToast() {
    const name = "burnttoast-module";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Get-Module -ListAvailable -Name BurntToast | Select-Object Version"',
        { timeout: 1e4 }
      );
      if (stdout.trim() && !stdout.includes("No modules")) {
        const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
        const version = versionMatch ? versionMatch[1] : "unknown";
        return {
          name,
          passed: true,
          fatal: true,
          message: `BurntToast module installed (version ${version})`,
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: true,
          message: "BurntToast PowerShell module not installed",
          remedy: "Install-Module BurntToast -Scope CurrentUser -Force",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: true,
        message: "Unable to check BurntToast module availability",
        remedy: "Check PowerShell execution policy and install: Install-Module BurntToast -Scope CurrentUser -Force",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check PowerShell execution policy (warning only)
   */
  async checkExecutionPolicy() {
    const name = "execution-policy";
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Get-ExecutionPolicy"',
        { timeout: 5e3 }
      );
      const policy = stdout.trim();
      const restrictivePolicies = ["Restricted", "AllSigned"];
      if (restrictivePolicies.includes(policy)) {
        return {
          name,
          passed: false,
          fatal: false,
          message: `PowerShell execution policy is restrictive: ${policy}`,
          remedy: "Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: true,
          fatal: false,
          message: `PowerShell execution policy: ${policy}`,
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "Unable to check PowerShell execution policy",
        remedy: "Check PowerShell access and consider setting: Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check jq binary availability (optional)
   */
  async checkJqBinary() {
    const name = "jq-binary";
    try {
      await execAsync("command -v jq", { timeout: 2e3 });
      return {
        name,
        passed: true,
        fatal: false,
        message: "jq binary available",
        timestamp: Date.now()
      };
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "jq binary not found",
        remedy: "Install jq: sudo apt-get install jq (Ubuntu/Debian) or brew install jq (macOS)",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Check Claude directory exists (warning only)
   */
  async checkClaudeDirectory() {
    const name = "claude-directory";
    const globalClaudeDir = join(homedir(), ".claude");
    try {
      if (existsSync(globalClaudeDir)) {
        return {
          name,
          passed: true,
          fatal: false,
          message: "Claude directory exists",
          timestamp: Date.now()
        };
      } else {
        return {
          name,
          passed: false,
          fatal: false,
          message: "Claude directory not found",
          remedy: "Install Claude Code first, or hooks will not function until Claude is installed",
          timestamp: Date.now()
        };
      }
    } catch {
      return {
        name,
        passed: false,
        fatal: false,
        message: "Unable to check Claude directory",
        remedy: "Ensure Claude Code is properly installed",
        timestamp: Date.now()
      };
    }
  }
  /**
   * Run a check function with caching support
   */
  async runWithCache(checkFn) {
    if (!this._forceRefresh) {
      const cachedResult = await this.getCachedResult(checkFn.name);
      if (cachedResult && this.isCacheValid(cachedResult)) {
        return cachedResult;
      }
    }
    return await checkFn();
  }
  /**
   * Get cached result for a specific check
   */
  async getCachedResult(checkName) {
    try {
      if (!existsSync(this.cacheFile)) {
        return null;
      }
      const cacheData = JSON.parse(
        await readFile(this.cacheFile, "utf8")
      );
      return cacheData[checkName] || null;
    } catch {
      return null;
    }
  }
  /**
   * Check if cached result is still valid (within 24h)
   */
  isCacheValid(result) {
    const age = Date.now() - result.timestamp;
    return age < this.cacheTimeoutMs;
  }
  /**
   * Save check results to cache
   */
  async saveCache(results) {
    try {
      await mkdir(this.cacheDir, { recursive: true });
      let cacheData = {};
      if (existsSync(this.cacheFile)) {
        try {
          cacheData = JSON.parse(await readFile(this.cacheFile, "utf8"));
        } catch {
          cacheData = {};
        }
      }
      for (const result of results) {
        cacheData[result.name] = result;
      }
      const tempFile = `${this.cacheFile}.tmp`;
      await writeFile(tempFile, JSON.stringify(cacheData, null, 2));
      await execAsync(`mv "${tempFile}" "${this.cacheFile}"`);
    } catch (error) {
      console.warn("Failed to save dependency check cache:", error);
    }
  }
};
var BurntToastAutoInstaller = class {
  async isInstalled() {
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Get-Module -ListAvailable -Name BurntToast"',
        { timeout: 1e4 }
      );
      return stdout.trim().length > 0 && !stdout.includes("No modules");
    } catch {
      return false;
    }
  }
  async promptInstall() {
    return true;
  }
  async install() {
    try {
      console.log("Installing BurntToast PowerShell module...");
      const { stderr } = await execAsync(
        'powershell.exe -Command "Install-Module BurntToast -Scope CurrentUser -Force -AllowClobber"',
        { timeout: 6e4 }
        // Allow up to 60 seconds for installation
      );
      if (stderr && !stderr.includes("WARNING")) {
        throw new Error(`Installation failed: ${stderr}`);
      }
      console.log("BurntToast module installed successfully");
    } catch (error) {
      throw new Error(
        `Failed to install BurntToast: ${error instanceof Error ? error.message : error}`
      );
    }
  }
  async verify() {
    try {
      const { stdout } = await execAsync(
        'powershell.exe -Command "Import-Module BurntToast -ErrorAction Stop; Write-Output success"',
        { timeout: 1e4 }
      );
      return stdout.trim() === "success";
    } catch {
      return false;
    }
  }
};

// src/jsonc-parser.ts
var JsoncParser = class _JsoncParser {
  content = "";
  position = 0;
  line = 1;
  column = 1;
  errors = [];
  /**
   * Parse JSONC content with comment support
   */
  parse(content, options = {}) {
    const {
      allowComments = true,
      stripComments = true
    } = options;
    this.content = content;
    this.position = 0;
    this.line = 1;
    this.column = 1;
    this.errors = [];
    try {
      let processedContent = content;
      if (allowComments && stripComments) {
        processedContent = this.stripComments(content);
      }
      const data = JSON.parse(processedContent);
      return { data, errors: this.errors };
    } catch (error) {
      if (error instanceof SyntaxError) {
        this.addError(this.extractJsonError(error.message));
      } else {
        this.addError("Unknown parsing error");
      }
      return { data: {}, errors: this.errors };
    }
  }
  /**
   * Strip single-line and multi-line comments from JSONC
   */
  stripComments(content) {
    let result = "";
    let i = 0;
    let line = 1;
    let column = 1;
    while (i < content.length) {
      const char = content[i];
      const nextChar = content[i + 1];
      if (char === "/" && nextChar === "/") {
        while (i < content.length && content[i] !== "\n") {
          i++;
          column++;
        }
        if (i < content.length && content[i] === "\n") {
          result += "\n";
          i++;
          line++;
          column = 1;
        }
        continue;
      }
      if (char === "/" && nextChar === "*") {
        const startLine = line;
        const startColumn = column;
        i += 2;
        column += 2;
        let found = false;
        while (i < content.length - 1) {
          if (content[i] === "*" && content[i + 1] === "/") {
            i += 2;
            column += 2;
            found = true;
            break;
          }
          if (content[i] === "\n") {
            result += "\n";
            line++;
            column = 1;
          }
          i++;
          column++;
        }
        if (!found) {
          this.addError(`Unterminated multi-line comment starting at line ${startLine}, column ${startColumn}`);
        }
        continue;
      }
      if (char === '"') {
        result += char;
        i++;
        column++;
        while (i < content.length) {
          const stringChar = content[i];
          result += stringChar;
          if (stringChar === '"' && content[i - 1] !== "\\") {
            i++;
            column++;
            break;
          }
          if (stringChar === "\n") {
            line++;
            column = 1;
          } else {
            column++;
          }
          i++;
        }
        continue;
      }
      result += char;
      if (char === "\n") {
        line++;
        column = 1;
      } else {
        column++;
      }
      i++;
    }
    return result;
  }
  /**
   * Extract useful error information from JSON parsing errors
   */
  extractJsonError(message) {
    const positionMatch = message.match(/at position (\d+)/);
    if (positionMatch) {
      const position = parseInt(positionMatch[1], 10);
      const { line, column } = this.getLineColumn(position);
      return `JSON syntax error at line ${line}, column ${column}: ${message}`;
    }
    return `JSON syntax error: ${message}`;
  }
  /**
   * Convert character position to line/column
   */
  getLineColumn(position) {
    let line = 1;
    let column = 1;
    for (let i = 0; i < position && i < this.content.length; i++) {
      if (this.content[i] === "\n") {
        line++;
        column = 1;
      } else {
        column++;
      }
    }
    return { line, column };
  }
  /**
   * Add parsing error with current position
   */
  addError(message) {
    this.errors.push({
      message,
      line: this.line,
      column: this.column,
      offset: this.position
    });
  }
  /**
   * Validate JSONC syntax without parsing
   */
  static validate(content) {
    const parser = new _JsoncParser();
    const result = parser.parse(content);
    return result.errors;
  }
  /**
   * Quick parse for when you just need the data and don't care about errors
   */
  static parseQuick(content) {
    const parser = new _JsoncParser();
    const result = parser.parse(content);
    return result.errors.length === 0 ? result.data : null;
  }
};

// src/settings-merger.ts
import { promises as fs } from "fs";
import path from "path";
import os from "os";
var SettingsMerger = class {
  jsonc = new JsoncParser();
  /**
   * Parse JSONC content into ClaudeSettings
   */
  async parseJsonc(content) {
    const result = this.jsonc.parse(content);
    if (result.errors.length > 0) {
      const errorMessages = result.errors.map((e) => e.message).join("; ");
      throw new Error(`JSONC parsing failed: ${errorMessages}`);
    }
    return result.data;
  }
  /**
   * Deep merge two settings objects with array deduplication
   */
  async merge(existing, updates, options = {}) {
    const {
      deduplicateArrays = true,
      preserveOrder = true
    } = options;
    const result = this.deepMerge(existing, updates, { deduplicateArrays, preserveOrder });
    return result;
  }
  /**
   * Read, merge, and write settings file atomically
   */
  async mergeFile(filePath, updates, options = {}) {
    const { createBackup = true } = options;
    let existing = {};
    let originalContent = "";
    try {
      originalContent = await fs.readFile(filePath, "utf-8");
      existing = await this.parseJsonc(originalContent);
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
    const merged = await this.merge(existing, updates, options);
    const changed = !this.isEqual(existing, merged);
    if (!changed) {
      return { merged, changed: false };
    }
    let backupPath;
    if (createBackup && originalContent) {
      backupPath = await this.createBackup(filePath, originalContent);
    }
    await this.writeAtomic(filePath, merged);
    return { merged, changed: true, backupPath };
  }
  /**
   * Deep merge implementation with special handling for arrays
   */
  deepMerge(target, source, options) {
    if (source === null || source === void 0) {
      return target;
    }
    if (target === null || target === void 0) {
      return this.deepClone(source);
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      return this.mergeArrays(target, source, options);
    }
    if (this.isObject(target) && this.isObject(source)) {
      const result = this.deepClone(target);
      for (const [key, value] of Object.entries(source)) {
        result[key] = this.deepMerge(result[key], value, options);
      }
      return result;
    }
    return this.deepClone(source);
  }
  /**
   * Merge arrays with deduplication and order preservation
   */
  mergeArrays(target, source, options) {
    const result = [...target];
    for (const item of source) {
      if (!options.deduplicateArrays || !this.arrayIncludes(result, item)) {
        if (options.preserveOrder) {
          result.push(item);
        } else {
          result.unshift(item);
        }
      }
    }
    return result;
  }
  /**
   * Check if array includes item (deep comparison)
   */
  arrayIncludes(array, item) {
    return array.some((existing) => this.isEqual(existing, item));
  }
  /**
   * Deep equality check
   */
  isEqual(a, b) {
    if (a === b) return true;
    if (a === null || b === null || a === void 0 || b === void 0) return false;
    if (typeof a !== typeof b) return false;
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      return a.every((item, index) => this.isEqual(item, b[index]));
    }
    if (this.isObject(a) && this.isObject(b)) {
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) return false;
      return keysA.every((key) => this.isEqual(a[key], b[key]));
    }
    return false;
  }
  /**
   * Deep clone an object
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (Array.isArray(obj)) return obj.map((item) => this.deepClone(item));
    const cloned = {};
    for (const [key, value] of Object.entries(obj)) {
      cloned[key] = this.deepClone(value);
    }
    return cloned;
  }
  /**
   * Check if value is a plain object
   */
  isObject(value) {
    return value !== null && typeof value === "object" && !Array.isArray(value);
  }
  /**
   * Create timestamped backup of original file
   */
  async createBackup(filePath, content) {
    const dir = path.dirname(filePath);
    const basename = path.basename(filePath);
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const backupDir = path.join(dir, "backup");
    const backupPath = path.join(backupDir, `${timestamp}-${basename}`);
    await fs.mkdir(backupDir, { recursive: true });
    await fs.writeFile(backupPath, content, "utf-8");
    return backupPath;
  }
  /**
   * Write JSON content atomically (temp file -> fsync -> rename)
   */
  async writeAtomic(filePath, data) {
    const dir = path.dirname(filePath);
    const tempPath = path.join(dir, `.${path.basename(filePath)}.tmp.${Date.now()}`);
    try {
      await fs.mkdir(dir, { recursive: true });
      const content = JSON.stringify(data, null, 2);
      await fs.writeFile(tempPath, content, "utf-8");
      const handle = await fs.open(tempPath, "r+");
      await handle.sync();
      await handle.close();
      await fs.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs.unlink(tempPath);
      } catch {
      }
      throw error;
    }
  }
  /**
   * Expand home directory in path
   */
  static expandPath(filePath) {
    if (filePath.startsWith("~")) {
      return path.join(os.homedir(), filePath.slice(1));
    }
    return filePath;
  }
};

// src/installer.ts
import { promises as fs2, constants } from "fs";
import path2 from "path";
import os2 from "os";
var Installer = class {
  constructor(config) {
    this.config = config;
  }
  merger = new SettingsMerger();
  /**
   * Main installation method
   */
  async install() {
    if (this.config.dryRun) {
      return this.dryRunInstall();
    }
    try {
      const paths = this.getInstallationPaths();
      await this.createInstallationDirectory(paths.installDir);
      const copiedFiles = await this.copyFiles(paths.installDir);
      await this.setPermissions(paths.installDir);
      const hookResult = await this.installHooks(paths);
      await this.createManifest(paths.installDir, copiedFiles, paths.settingsPath, hookResult.hooksAdded);
      return {
        success: true,
        installedTo: paths.installDir,
        settingsPath: paths.settingsPath,
        backupPath: hookResult.backupPath,
        hooksAdded: hookResult.hooksAdded,
        message: `Successfully installed cctoast-wsl to ${paths.installDir}`
      };
    } catch (error) {
      return {
        success: false,
        installedTo: "",
        settingsPath: "",
        hooksAdded: [],
        message: `Installation failed: ${error.message}`
      };
    }
  }
  /**
   * Dry run installation to show what would be done
   */
  async dryRunInstall() {
    const paths = this.getInstallationPaths();
    const hooks = this.generateHookCommands(paths.installDir);
    const hooksAdded = [];
    if (this.config.notificationHook) {
      hooksAdded.push("notification");
    }
    if (this.config.stopHook) {
      hooksAdded.push("stop");
    }
    const message = [
      "DRY RUN - No changes would be made:",
      `Install directory: ${paths.installDir}`,
      `Settings file: ${paths.settingsPath}`,
      `Hooks to add: ${hooksAdded.join(", ")}`,
      `Hook commands:`,
      ...Object.entries(hooks).map(([key, cmd]) => `  ${key}: ${cmd}`)
    ].join("\n");
    return {
      success: true,
      installedTo: paths.installDir,
      settingsPath: paths.settingsPath,
      hooksAdded,
      message
    };
  }
  /**
   * Determine installation paths based on config
   */
  getInstallationPaths() {
    const isGlobal = this.config.global || !this.config.local;
    if (isGlobal) {
      const homeDir = os2.homedir();
      const installDir = path2.join(homeDir, ".claude", "cctoast-wsl");
      const settingsPath = path2.join(homeDir, ".claude", "settings.json");
      return { installDir, settingsPath, scope: "global" };
    } else {
      const cwd = process.cwd();
      const installDir = path2.join(cwd, ".claude", "cctoast-wsl");
      const settingsPath = this.config.sync ? path2.join(cwd, ".claude", "settings.json") : path2.join(cwd, ".claude", "settings.local.json");
      return { installDir, settingsPath, scope: "local" };
    }
  }
  /**
   * Create installation directory
   */
  async createInstallationDirectory(installDir) {
    await fs2.mkdir(installDir, { recursive: true });
    await fs2.mkdir(path2.join(installDir, "assets"), { recursive: true });
  }
  /**
   * Copy scripts and assets to installation directory
   */
  async copyFiles(installDir) {
    const copiedFiles = [];
    const scriptSource = path2.join(process.cwd(), "scripts", "show-toast.sh");
    const scriptDest = path2.join(installDir, "show-toast.sh");
    await fs2.copyFile(scriptSource, scriptDest);
    copiedFiles.push("show-toast.sh");
    const iconSource = path2.join(process.cwd(), "assets", "claude.png");
    const iconDest = path2.join(installDir, "assets", "claude.png");
    try {
      await fs2.copyFile(iconSource, iconDest);
      copiedFiles.push("assets/claude.png");
    } catch (error) {
      console.warn("Warning: Could not copy claude.png icon");
    }
    return copiedFiles;
  }
  /**
   * Set proper permissions on installed files
   */
  async setPermissions(installDir) {
    const scriptPath = path2.join(installDir, "show-toast.sh");
    await fs2.chmod(scriptPath, 320);
  }
  /**
   * Install hooks into Claude settings
   */
  async installHooks(paths) {
    const hookCommands = this.generateHookCommands(paths.installDir);
    const updates = { hooks: {} };
    const hooksAdded = [];
    if (this.config.notificationHook) {
      updates.hooks.notification = [hookCommands.notification];
      hooksAdded.push("notification");
    }
    if (this.config.stopHook) {
      updates.hooks.stop = [hookCommands.stop];
      hooksAdded.push("stop");
    }
    const result = await this.merger.mergeFile(paths.settingsPath, updates, {
      deduplicateArrays: true,
      preserveOrder: true,
      createBackup: true
    });
    return {
      hooksAdded,
      backupPath: result.backupPath,
      changed: result.changed
    };
  }
  /**
   * Generate hook commands with direct script paths
   */
  generateHookCommands(installDir) {
    const scriptPath = path2.join(installDir, "show-toast.sh");
    return {
      notification: `${scriptPath} --notification-hook`,
      stop: `${scriptPath} --stop-hook`
    };
  }
  /**
   * Create installation manifest for uninstall tracking
   */
  async createManifest(installDir, files, settingsPath, hooksInstalled) {
    const manifest = {
      version: "1.0.0",
      // TODO: Get from package.json
      installedAt: (/* @__PURE__ */ new Date()).toISOString(),
      config: this.config,
      files,
      settingsPath,
      hooksInstalled
    };
    const manifestPath = path2.join(installDir, "install-manifest.json");
    await fs2.writeFile(manifestPath, JSON.stringify(manifest, null, 2), "utf-8");
  }
  /**
   * Uninstall cctoast-wsl
   */
  async uninstall() {
    try {
      const paths = this.getInstallationPaths();
      const manifestPath = path2.join(paths.installDir, "install-manifest.json");
      let manifest = null;
      try {
        const manifestContent = await fs2.readFile(manifestPath, "utf-8");
        manifest = JSON.parse(manifestContent);
      } catch {
      }
      const removedHooks = await this.removeHooks(paths, manifest);
      await fs2.rm(paths.installDir, { recursive: true, force: true });
      return {
        success: true,
        installedTo: paths.installDir,
        settingsPath: paths.settingsPath,
        hooksAdded: [],
        // Actually removed
        message: `Successfully uninstalled cctoast-wsl from ${paths.installDir}. Removed hooks: ${removedHooks.join(", ")}`
      };
    } catch (error) {
      return {
        success: false,
        installedTo: "",
        settingsPath: "",
        hooksAdded: [],
        message: `Uninstall failed: ${error.message}`
      };
    }
  }
  /**
   * Remove hooks from Claude settings
   */
  async removeHooks(paths, manifest) {
    const removedHooks = [];
    try {
      const content = await fs2.readFile(paths.settingsPath, "utf-8");
      const settings = await this.merger.parseJsonc(content);
      if (!settings.hooks) return removedHooks;
      const hookCommands = this.generateHookCommands(paths.installDir);
      for (const [hookType, command] of Object.entries(hookCommands)) {
        const hooks = settings.hooks[hookType];
        if (hooks) {
          const filtered = hooks.filter((hook) => hook !== command);
          if (filtered.length !== hooks.length) {
            settings.hooks[hookType] = filtered.length > 0 ? filtered : void 0;
            removedHooks.push(hookType);
          }
        }
      }
      await this.merger.mergeFile(paths.settingsPath, settings, {
        createBackup: true
      });
    } catch (error) {
    }
    return removedHooks;
  }
  /**
   * Check if cctoast-wsl is installed
   */
  async isInstalled() {
    const paths = this.getInstallationPaths();
    try {
      await fs2.access(paths.installDir, constants.F_OK);
      await fs2.access(path2.join(paths.installDir, "show-toast.sh"), constants.F_OK);
      return true;
    } catch {
      return false;
    }
  }
};

// src/cli.ts
var __dirname = fileURLToPath(new URL(".", import.meta.url));
var packagePath = join2(__dirname, "..", "package.json");
var packageJson = JSON.parse(readFileSync(packagePath, "utf8"));
var ExitCodes = {
  SUCCESS: 0,
  USER_ABORT: 1,
  DEPENDENCY_FAILURE: 2,
  IO_ERROR: 3
};
function initializeCLI() {
  const program = new Command();
  program.name("cctoast-wsl").description(
    "Secure, zero-admin utility for Windows toast notifications from WSL via Claude Code hooks"
  ).version(packageJson.version, "-v, --version", "Display version number");
  program.option("-g, --global", "Install for user to ~/.claude/... (default)").option("-l, --local", "Install for project to .claude/...").addHelpText(
    "after",
    "\nScope Options:\n  Only one of --global or --local can be specified"
  );
  program.option("--notification", "Include Notification hook (default)", true).option("--no-notification", "Exclude Notification hook").option("--stop", "Include Stop hook (default)", true).option("--no-stop", "Exclude Stop hook");
  program.option(
    "--sync",
    "When local, modify tracked settings.json instead of settings.local.json (not recommended for teams due to Windows-only nature of hooks)",
    false
  );
  program.option("-p, --print-instructions", "Show usage instructions and exit").option("--json", "Machine-readable JSON output", false).option("-n, --dry-run", "Preview changes without writing files").option(
    "-f, --force",
    "Bypass failed dependency checks (except BurntToast)"
  ).option("-q, --quiet", "Suppress interactive prompts for CI environments");
  program.option("--uninstall", "Remove cctoast-wsl installation");
  return program;
}
function validateFlags(options) {
  if (!options.global && !options.local) {
    options.global = true;
  }
  if (options.global && options.local) {
    console.error("Error: --global and --local flags cannot be used together");
    process2.exit(ExitCodes.USER_ABORT);
  }
  if (!options.notification && !options.stop) {
    console.error(
      "Error: At least one hook (--notification or --stop) must be enabled"
    );
    process2.exit(ExitCodes.USER_ABORT);
  }
  if (options.sync && !options.local) {
    console.error("Warning: --sync flag only applies to local installations");
  }
}
function handlePrintInstructions() {
  console.log(`
cctoast-wsl v${packageJson.version} - Usage Instructions

INSTALLATION:
  npx @claude/cctoast-wsl                    # Global install with defaults
  npx @claude/cctoast-wsl --local           # Local project install
  npx @claude/cctoast-wsl --dry-run         # Preview changes

EXAMPLES:
  npx @claude/cctoast-wsl --global --notification --stop
  npx @claude/cctoast-wsl --local --sync --no-stop
  npx @claude/cctoast-wsl --uninstall --global

HOOK USAGE:
  After installation, Claude Code will automatically trigger toast notifications:
  - Notification hook: Shows when Claude is waiting for input
  - Stop hook: Shows when Claude completes a task

MANUAL TESTING:
  ~/.claude/cctoast-wsl/show-toast.sh --notification-hook
  ~/.claude/cctoast-wsl/show-toast.sh --stop-hook

For complete documentation: https://github.com/claudes-world/cctoast-wsl
`);
  process2.exit(ExitCodes.SUCCESS);
}
function isInteractive() {
  return process2.stdin.isTTY && process2.stdout.isTTY;
}
function handleCancel() {
  p.cancel("Operation cancelled by user");
  process2.exit(ExitCodes.USER_ABORT);
}
async function runInteractiveMode() {
  p.intro("\u{1F35E} cctoast-wsl Installation");
  const scope = await p.select({
    message: "Choose installation scope:",
    options: [
      {
        value: "global",
        label: "Global",
        hint: "\u2605 Recommended - Install to ~/.claude/"
      },
      {
        value: "local",
        label: "Local",
        hint: "Install to current project .claude/"
      }
    ]
  });
  if (p.isCancel(scope)) {
    handleCancel();
  }
  const scopeValue = scope;
  const hooks = await p.multiselect({
    message: "Select hooks to enable:",
    options: [
      {
        value: "notification",
        label: "Notification hook",
        hint: "Shows toast when Claude is waiting for input"
      },
      {
        value: "stop",
        label: "Stop hook",
        hint: "Shows toast when Claude completes a task"
      }
    ],
    initialValues: ["notification", "stop"],
    required: true
  });
  if (p.isCancel(hooks)) {
    handleCancel();
  }
  let sync = false;
  if (scopeValue === "local") {
    const syncResult = await p.confirm({
      message: "Modify tracked settings.json instead of settings.local.json?",
      initialValue: false
    });
    if (p.isCancel(syncResult)) {
      handleCancel();
    }
    sync = syncResult;
  }
  const hooksList = hooks;
  const summary = [
    `Scope: ${scopeValue}`,
    `Hooks: ${hooksList.join(", ")}`,
    ...scopeValue === "local" ? [`Sync: ${sync ? "yes" : "no"}`] : []
  ];
  p.log.info(
    `Configuration summary:
${summary.map((item) => `  \u2022 ${item}`).join("\n")}`
  );
  let configExplanation = "";
  if (scopeValue === "global") {
    configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your global settings at ~/.claude/settings.json.
The cctoast-wsl tool will install the necessary scripts and configuration for Windows toast notifications, available to all WSL sessions for your user.`;
  } else if (scopeValue === "local") {
    if (sync) {
      configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your project's tracked settings at ./.claude/settings.json.
This will update the main project settings (recommended only if your team is Windows-only).`;
    } else {
      configExplanation = `
Hooks for ${hooksList.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(" and ")} will be added to your local-only settings at ./.claude/settings.local.json.
This keeps Windows-specific configuration out of version control, ideal for cross-platform teams.`;
    }
    configExplanation += "\nThe cctoast-wsl tool will install the necessary scripts and configuration for toast notifications in this project.";
  }
  if (configExplanation) {
    p.log.message(configExplanation);
  }
  const proceed = await p.confirm({
    message: "Proceed with installation?",
    initialValue: true
  });
  if (p.isCancel(proceed) || !proceed) {
    handleCancel();
  }
  p.outro("Ready to install! \u{1F389}");
  return {
    global: scopeValue === "global",
    local: scopeValue === "local",
    notification: hooksList.includes("notification"),
    stop: hooksList.includes("stop"),
    sync,
    printInstructions: false,
    json: false,
    dryRun: false,
    force: false,
    quiet: false,
    uninstall: false
  };
}
function setupSignalHandlers() {
  process2.on("SIGINT", () => {
    p.cancel("\nOperation cancelled by user");
    process2.exit(ExitCodes.USER_ABORT);
  });
  process2.on("SIGTERM", () => {
    p.cancel("\nOperation terminated");
    process2.exit(ExitCodes.USER_ABORT);
  });
}
async function runDependencyChecks(options) {
  const s = p.spinner();
  s.start("Checking system dependencies...");
  if (!options.quiet) {
    console.log("\u{1F50D} Checking system dependencies...\n");
  }
  const checker = new DependencyChecker(options.force);
  const results = await checker.checkAll();
  const fatalFailures = results.filter((r) => !r.passed && r.fatal);
  const warnings = results.filter((r) => !r.passed && !r.fatal);
  const passed = results.filter((r) => r.passed);
  if (!options.quiet) {
    passed.forEach((result) => {
      p.log.message(`${result.message}`, { symbol: import_picocolors.default.cyan("\u2714") });
    });
    warnings.forEach((result) => {
      console.log(`\u26A0\uFE0F  ${result.message}`);
      if (result.remedy) {
        console.log(`   \u{1F4A1} ${result.remedy}`);
      }
    });
  }
  if (fatalFailures.length > 0) {
    if (!options.quiet) {
      console.log("\n\u274C Fatal dependency checks failed:\n");
      fatalFailures.forEach((result) => {
        console.log(`   \u2022 ${result.message}`);
        if (result.remedy) {
          console.log(`     Fix: ${result.remedy}`);
        }
      });
    }
    const burntToastFailure = fatalFailures.find(
      (r) => r.name === "burnttoast-module"
    );
    if (burntToastFailure && !options.quiet) {
      const autoInstaller = new BurntToastAutoInstaller();
      try {
        console.log("\n\u{1F916} Auto-installation available for BurntToast module");
        const consent = await p.confirm({
          message: "Would you like to automatically install BurntToast PowerShell module?",
          initialValue: true
        });
        if (p.isCancel(consent)) {
          handleCancel();
        }
        if (consent) {
          await autoInstaller.install();
          if (await autoInstaller.verify()) {
            console.log(
              "\u2705 BurntToast module installed and verified successfully"
            );
            const remainingFailures = fatalFailures.filter(
              (r) => r.name !== "burnttoast-module"
            );
            if (remainingFailures.length === 0) {
              console.log("\n\u{1F389} All dependency checks now pass!");
              return;
            }
          } else {
            console.log("\u274C BurntToast installation verification failed");
          }
        }
      } catch (error) {
        console.log(
          `\u274C Auto-installation failed: ${error instanceof Error ? error.message : error}`
        );
      }
    }
    if (!options.force || fatalFailures.some((r) => r.name === "burnttoast-module")) {
      console.log(
        "\n\u{1F4A1} Use --force to bypass non-fatal checks, but BurntToast is required"
      );
      process2.exit(ExitCodes.DEPENDENCY_FAILURE);
    }
  }
  if (!options.quiet && warnings.length === 0 && fatalFailures.length === 0) {
    console.log("\n\u{1F389} All dependency checks passed!");
  }
  s.stop();
}
function hasExplicitFlags(argv) {
  const flagsToCheck = [
    "--global",
    "-g",
    "--local",
    "-l",
    "--no-notification",
    "--no-stop",
    "--sync",
    "--json",
    "--dry-run",
    "-n",
    "--force",
    "-f",
    "--quiet",
    "-q",
    "--uninstall"
  ];
  return flagsToCheck.some((flag) => argv.includes(flag));
}
async function main() {
  try {
    setupSignalHandlers();
    const program = initializeCLI();
    program.parse();
    let options = program.opts();
    if (options.printInstructions) {
      handlePrintInstructions();
      return;
    }
    const shouldUseInteractive = !options.quiet && isInteractive() && !hasExplicitFlags(process2.argv);
    if (shouldUseInteractive) {
      options = await runInteractiveMode();
    } else {
      validateFlags(options);
    }
    if (options.json) {
      const checker = new DependencyChecker(options.force);
      const depResults = await checker.checkAll();
      const result = {
        action: options.uninstall ? "uninstall" : "install",
        scope: options.local ? "local" : "global",
        hooks: {
          notification: options.notification,
          stop: options.stop
        },
        settings: {
          sync: options.sync,
          dryRun: options.dryRun,
          force: options.force,
          quiet: options.quiet
        },
        dependencies: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          results: depResults.map((r) => ({
            name: r.name,
            passed: r.passed,
            fatal: r.fatal,
            message: r.message,
            remedy: r.remedy
          })),
          summary: {
            total: depResults.length,
            passed: depResults.filter((r) => r.passed).length,
            failed: depResults.filter((r) => !r.passed).length,
            fatal: depResults.filter((r) => !r.passed && r.fatal).length,
            warnings: depResults.filter((r) => !r.passed && !r.fatal).length
          }
        }
      };
      console.log(JSON.stringify(result, null, 2));
      const fatalFailures = depResults.filter((r) => !r.passed && r.fatal);
      if (fatalFailures.length > 0 && !options.force) {
        process2.exit(ExitCodes.DEPENDENCY_FAILURE);
      }
    } else {
      await runDependencyChecks(options);
    }
    if (options.dryRun && !options.json) {
      console.log("\n\u{1F4CB} DRY RUN MODE - No files will be modified");
    }
    const installer = new Installer({
      global: options.global || !options.local,
      local: options.local,
      notificationHook: options.notification,
      stopHook: options.stop,
      sync: options.sync,
      dryRun: options.dryRun
    });
    try {
      let installResult;
      if (options.uninstall) {
        installResult = await installer.uninstall();
      } else {
        installResult = await installer.install();
      }
      if (options.json) {
        const jsonResult = {
          action: options.uninstall ? "uninstall" : "install",
          scope: options.local ? "local" : "global",
          hooks: {
            notification: options.notification,
            stop: options.stop
          },
          settings: {
            sync: options.sync,
            dryRun: options.dryRun,
            force: options.force,
            quiet: options.quiet
          },
          installation: {
            success: installResult.success,
            installedTo: installResult.installedTo,
            settingsPath: installResult.settingsPath,
            backupPath: installResult.backupPath,
            hooksAdded: installResult.hooksAdded,
            message: installResult.message
          }
        };
        console.log(JSON.stringify(jsonResult, null, 2));
      } else {
        if (installResult.success) {
          console.log(`
${installResult.message}`);
          if (installResult.backupPath) {
            console.log(`\u{1F4C1} Backup created: ${installResult.backupPath}`);
          }
          if (installResult.hooksAdded.length > 0) {
            console.log(`\u{1FA9D} Hooks added: ${installResult.hooksAdded.join(", ")}`);
          }
        } else {
          console.error(`
\u274C ${installResult.message}`);
          process2.exit(ExitCodes.IO_ERROR);
        }
      }
    } catch (error) {
      const errorMessage = `Installation failed: ${error instanceof Error ? error.message : error}`;
      if (options.json) {
        console.log(JSON.stringify({ error: errorMessage }, null, 2));
      } else {
        console.error(`
\u274C ${errorMessage}`);
      }
      process2.exit(ExitCodes.IO_ERROR);
    }
  } catch (error) {
    console.error(
      "Unexpected error:",
      error instanceof Error ? error.message : error
    );
    process2.exit(ExitCodes.IO_ERROR);
  }
}
if (import.meta.url === `file://${process2.argv[1]}`) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    process2.exit(ExitCodes.IO_ERROR);
  });
}
export {
  ExitCodes,
  initializeCLI,
  main,
  validateFlags
};
//# sourceMappingURL=cctoast-wsl.map
