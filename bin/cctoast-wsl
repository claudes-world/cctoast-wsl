#!/usr/bin/env node

var W=Object.create;var T=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var H=Object.getPrototypeOf,J=Object.prototype.hasOwnProperty;var _=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports);var G=(a,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of q(e))!J.call(a,o)&&o!==t&&T(a,o,{get:()=>e[o],enumerable:!(s=L(e,o))||s.enumerable});return a};var Y=(a,e,t)=>(t=a!=null?W(H(a)):{},G(e||!a||!a.__esModule?T(t,"default",{value:a,enumerable:!0}):t,a));var $=_((we,I)=>{var C=process||{},D=C.argv||[],x=C.env||{},V=!(x.NO_COLOR||D.includes("--no-color"))&&(!!x.FORCE_COLOR||D.includes("--color")||C.platform==="win32"||(C.stdout||{}).isTTY&&x.TERM!=="dumb"||!!x.CI),K=(a,e,t=a)=>s=>{let o=""+s,n=o.indexOf(e,a.length);return~n?a+z(o,e,t,n)+e:a+o+e},z=(a,e,t,s)=>{let o="",n=0;do o+=a.substring(n,s)+t,n=s+e.length,s=a.indexOf(e,n);while(~s);return o+a.substring(n)},B=(a=V)=>{let e=a?K:()=>String;return{isColorSupported:a,reset:e("\x1B[0m","\x1B[0m"),bold:e("\x1B[1m","\x1B[22m","\x1B[22m\x1B[1m"),dim:e("\x1B[2m","\x1B[22m","\x1B[22m\x1B[2m"),italic:e("\x1B[3m","\x1B[23m"),underline:e("\x1B[4m","\x1B[24m"),inverse:e("\x1B[7m","\x1B[27m"),hidden:e("\x1B[8m","\x1B[28m"),strikethrough:e("\x1B[9m","\x1B[29m"),black:e("\x1B[30m","\x1B[39m"),red:e("\x1B[31m","\x1B[39m"),green:e("\x1B[32m","\x1B[39m"),yellow:e("\x1B[33m","\x1B[39m"),blue:e("\x1B[34m","\x1B[39m"),magenta:e("\x1B[35m","\x1B[39m"),cyan:e("\x1B[36m","\x1B[39m"),white:e("\x1B[37m","\x1B[39m"),gray:e("\x1B[90m","\x1B[39m"),bgBlack:e("\x1B[40m","\x1B[49m"),bgRed:e("\x1B[41m","\x1B[49m"),bgGreen:e("\x1B[42m","\x1B[49m"),bgYellow:e("\x1B[43m","\x1B[49m"),bgBlue:e("\x1B[44m","\x1B[49m"),bgMagenta:e("\x1B[45m","\x1B[49m"),bgCyan:e("\x1B[46m","\x1B[49m"),bgWhite:e("\x1B[47m","\x1B[49m"),blackBright:e("\x1B[90m","\x1B[39m"),redBright:e("\x1B[91m","\x1B[39m"),greenBright:e("\x1B[92m","\x1B[39m"),yellowBright:e("\x1B[93m","\x1B[39m"),blueBright:e("\x1B[94m","\x1B[39m"),magentaBright:e("\x1B[95m","\x1B[39m"),cyanBright:e("\x1B[96m","\x1B[39m"),whiteBright:e("\x1B[97m","\x1B[39m"),bgBlackBright:e("\x1B[100m","\x1B[49m"),bgRedBright:e("\x1B[101m","\x1B[49m"),bgGreenBright:e("\x1B[102m","\x1B[49m"),bgYellowBright:e("\x1B[103m","\x1B[49m"),bgBlueBright:e("\x1B[104m","\x1B[49m"),bgMagentaBright:e("\x1B[105m","\x1B[49m"),bgCyanBright:e("\x1B[106m","\x1B[49m"),bgWhiteBright:e("\x1B[107m","\x1B[49m")}};I.exports=B();I.exports.createColors=B});var U=Y($(),1);import{Command as oe}from"commander";import u from"node:process";import{readFileSync as ne}from"node:fs";import{join as ae}from"node:path";import{fileURLToPath as ie}from"node:url";import*as c from"@clack/prompts";import{exec as Q}from"node:child_process";import{promisify as X}from"node:util";import{readFile as E,writeFile as Z,mkdir as ee}from"node:fs/promises";import{existsSync as A}from"node:fs";import{join as j}from"node:path";import{homedir as F}from"node:os";var g=X(Q),w=class{constructor(e=!1){this._forceRefresh=e}cacheDir=j(F(),".cache","cctoast-wsl");cacheFile=j(this.cacheDir,"checks.json");cacheTimeoutMs=1440*60*1e3;async checkAll(){let e=[()=>this.checkWSLEnvironment(),()=>this.checkPowerShellAccess(),()=>this.checkBurntToast(),()=>this.checkJqBinary(),()=>this.checkClaudeDirectory()],t=[];for(let s of e)try{let o=await this.runWithCache(s);t.push(o)}catch(o){let n={name:"unknown",passed:!1,fatal:!0,message:`Check failed: ${o instanceof Error?o.message:o}`,timestamp:Date.now()};t.push(n)}return await this.saveCache(t),t}async checkWSLEnvironment(){let e="wsl-environment";try{let t=await E("/proc/version","utf8"),s=t.includes("Microsoft"),o=t.includes("WSL2")||t.includes("microsoft-standard");return s||o?{name:e,passed:!0,fatal:!0,message:`Detected ${o?"WSL2":"WSL1"} environment`,timestamp:Date.now()}:{name:e,passed:!1,fatal:!0,message:"Not running in WSL environment",remedy:"Run inside Windows Subsystem for Linux (WSL)",timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!0,message:"Unable to detect WSL environment",remedy:"Ensure you are running inside WSL",timestamp:Date.now()}}}async checkPowerShellAccess(){let e="powershell-exe";try{let{stdout:t}=await g('powershell.exe -Command "Write-Output test"',{timeout:5e3});return t.trim()==="test"?{name:e,passed:!0,fatal:!0,message:"PowerShell.exe accessible and functional",timestamp:Date.now()}:{name:e,passed:!1,fatal:!0,message:"PowerShell.exe not responding correctly",remedy:"Add Windows PowerShell to PATH or check WSL interop settings",timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!0,message:"PowerShell.exe not accessible from PATH",remedy:'Add Windows PowerShell to PATH: export PATH="$PATH:/mnt/c/Windows/System32/WindowsPowerShell/v1.0"',timestamp:Date.now()}}}async checkBurntToast(){let e="burnttoast-module";try{let{stdout:t}=await g('powershell.exe -Command "Get-Module -ListAvailable -Name BurntToast | Select-Object Version"',{timeout:1e4});if(t.trim()&&!t.includes("No modules")){let s=t.match(/(\d+\.\d+\.\d+)/),o=s?s[1]:"unknown";return{name:e,passed:!0,fatal:!0,message:`BurntToast module installed (version ${o})`,timestamp:Date.now()}}else return{name:e,passed:!1,fatal:!0,message:"BurntToast PowerShell module not installed",remedy:"Install-Module BurntToast -Scope CurrentUser -Force",timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!0,message:"Unable to check BurntToast module availability",remedy:"Check PowerShell execution policy and install: Install-Module BurntToast -Scope CurrentUser -Force",timestamp:Date.now()}}}async checkExecutionPolicy(){let e="execution-policy";try{let{stdout:t}=await g('powershell.exe -Command "Get-ExecutionPolicy"',{timeout:5e3}),s=t.trim();return["Restricted","AllSigned"].includes(s)?{name:e,passed:!1,fatal:!1,message:`PowerShell execution policy is restrictive: ${s}`,remedy:"Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",timestamp:Date.now()}:{name:e,passed:!0,fatal:!1,message:`PowerShell execution policy: ${s}`,timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!1,message:"Unable to check PowerShell execution policy",remedy:"Check PowerShell access and consider setting: Set-ExecutionPolicy -Scope CurrentUser RemoteSigned",timestamp:Date.now()}}}async checkJqBinary(){let e="jq-binary";try{return await g("command -v jq",{timeout:2e3}),{name:e,passed:!0,fatal:!1,message:"jq binary available",timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!1,message:"jq binary not found",remedy:"Install jq: sudo apt-get install jq (Ubuntu/Debian) or brew install jq (macOS)",timestamp:Date.now()}}}async checkClaudeDirectory(){let e="claude-directory",t=j(F(),".claude");try{return A(t)?{name:e,passed:!0,fatal:!1,message:"Claude directory exists",timestamp:Date.now()}:{name:e,passed:!1,fatal:!1,message:"Claude directory not found",remedy:"Install Claude Code first, or hooks will not function until Claude is installed",timestamp:Date.now()}}catch{return{name:e,passed:!1,fatal:!1,message:"Unable to check Claude directory",remedy:"Ensure Claude Code is properly installed",timestamp:Date.now()}}}async runWithCache(e){if(!this._forceRefresh){let t=await this.getCachedResult(e.name);if(t&&this.isCacheValid(t))return t}return await e()}async getCachedResult(e){try{return A(this.cacheFile)&&JSON.parse(await E(this.cacheFile,"utf8"))[e]||null}catch{return null}}isCacheValid(e){return Date.now()-e.timestamp<this.cacheTimeoutMs}async saveCache(e){try{await ee(this.cacheDir,{recursive:!0});let t={};if(A(this.cacheFile))try{t=JSON.parse(await E(this.cacheFile,"utf8"))}catch{t={}}for(let o of e)t[o.name]=o;let s=`${this.cacheFile}.tmp`;await Z(s,JSON.stringify(t,null,2)),await g(`mv "${s}" "${this.cacheFile}"`)}catch(t){console.warn("Failed to save dependency check cache:",t)}}},v=class{async isInstalled(){try{let{stdout:e}=await g('powershell.exe -Command "Get-Module -ListAvailable -Name BurntToast"',{timeout:1e4});return e.trim().length>0&&!e.includes("No modules")}catch{return!1}}async promptInstall(){return!0}async install(){try{console.log("Installing BurntToast PowerShell module...");let{stderr:e}=await g('powershell.exe -Command "Install-Module BurntToast -Scope CurrentUser -Force -AllowClobber"',{timeout:6e4});if(e&&!e.includes("WARNING"))throw new Error(`Installation failed: ${e}`);console.log("BurntToast module installed successfully")}catch(e){throw new Error(`Failed to install BurntToast: ${e instanceof Error?e.message:e}`)}}async verify(){try{let{stdout:e}=await g('powershell.exe -Command "Import-Module BurntToast -ErrorAction Stop; Write-Output success"',{timeout:1e4});return e.trim()==="success"}catch{return!1}}};var S=class a{content="";position=0;line=1;column=1;errors=[];parse(e,t={}){let{allowComments:s=!0,stripComments:o=!0}=t;this.content=e,this.position=0,this.line=1,this.column=1,this.errors=[];try{let n=e;return s&&o&&(n=this.stripComments(e)),{data:JSON.parse(n),errors:this.errors}}catch(n){return n instanceof SyntaxError?this.addError(this.extractJsonError(n.message)):this.addError("Unknown parsing error"),{data:{},errors:this.errors}}}stripComments(e){let t="",s=0,o=1,n=1;for(;s<e.length;){let r=e[s],l=e[s+1];if(r==="/"&&l==="/"){for(;s<e.length&&e[s]!==`
`;)s++,n++;s<e.length&&e[s]===`
`&&(t+=`
`,s++,o++,n=1);continue}if(r==="/"&&l==="*"){let i=o,m=n;s+=2,n+=2;let f=!1;for(;s<e.length-1;){if(e[s]==="*"&&e[s+1]==="/"){s+=2,n+=2,f=!0;break}e[s]===`
`&&(t+=`
`,o++,n=1),s++,n++}f||this.addError(`Unterminated multi-line comment starting at line ${i}, column ${m}`);continue}if(r==='"'){for(t+=r,s++,n++;s<e.length;){let i=e[s];if(t+=i,i==='"'&&e[s-1]!=="\\"){s++,n++;break}i===`
`?(o++,n=1):n++,s++}continue}t+=r,r===`
`?(o++,n=1):n++,s++}return t}extractJsonError(e){let t=e.match(/at position (\d+)/);if(t){let s=parseInt(t[1],10),{line:o,column:n}=this.getLineColumn(s);return`JSON syntax error at line ${o}, column ${n}: ${e}`}return`JSON syntax error: ${e}`}getLineColumn(e){let t=1,s=1;for(let o=0;o<e&&o<this.content.length;o++)this.content[o]===`
`?(t++,s=1):s++;return{line:t,column:s}}addError(e){this.errors.push({message:e,line:this.line,column:this.column,offset:this.position})}static validate(e){return new a().parse(e).errors}static parseQuick(e){let s=new a().parse(e);return s.errors.length===0?s.data:null}};import{promises as b}from"fs";import y from"path";import te from"os";var P=class{jsonc=new S;async parseJsonc(e){let t=this.jsonc.parse(e);if(t.errors.length>0){let s=t.errors.map(o=>o.message).join("; ");throw new Error(`JSONC parsing failed: ${s}`)}return t.data}async merge(e,t,s={}){let{deduplicateArrays:o=!0,preserveOrder:n=!0}=s;return this.deepMerge(e,t,{deduplicateArrays:o,preserveOrder:n})}async mergeFile(e,t,s={}){let{createBackup:o=!0}=s,n={},r="";try{r=await b.readFile(e,"utf-8"),n=await this.parseJsonc(r)}catch(f){if(f.code!=="ENOENT")throw f}let l=await this.merge(n,t,s);if(!!this.isEqual(n,l))return{merged:l,changed:!1};let m;return o&&r&&(m=await this.createBackup(e,r)),await this.writeAtomic(e,l),{merged:l,changed:!0,backupPath:m}}deepMerge(e,t,s){if(t==null)return e;if(e==null)return this.deepClone(t);if(Array.isArray(e)&&Array.isArray(t))return this.mergeArrays(e,t,s);if(this.isObject(e)&&this.isObject(t)){let o=this.deepClone(e);for(let[n,r]of Object.entries(t))o[n]=this.deepMerge(o[n],r,s);return o}return this.deepClone(t)}mergeArrays(e,t,s){let o=[...e];for(let n of t)(!s.deduplicateArrays||!this.arrayIncludes(o,n))&&(s.preserveOrder?o.push(n):o.unshift(n));return o}arrayIncludes(e,t){return e.some(s=>this.isEqual(s,t))}isEqual(e,t){if(e===t)return!0;if(e===null||t===null||e===void 0||t===void 0||typeof e!=typeof t)return!1;if(Array.isArray(e)&&Array.isArray(t))return e.length!==t.length?!1:e.every((s,o)=>this.isEqual(s,t[o]));if(this.isObject(e)&&this.isObject(t)){let s=Object.keys(e),o=Object.keys(t);return s.length!==o.length?!1:s.every(n=>this.isEqual(e[n],t[n]))}return!1}deepClone(e){if(e===null||typeof e!="object")return e;if(Array.isArray(e))return e.map(s=>this.deepClone(s));let t={};for(let[s,o]of Object.entries(e))t[s]=this.deepClone(o);return t}isObject(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)}async createBackup(e,t){let s=y.dirname(e),o=y.basename(e),n=new Date().toISOString().replace(/[:.]/g,"-"),r=y.join(s,"backup"),l=y.join(r,`${n}-${o}`);return await b.mkdir(r,{recursive:!0}),await b.writeFile(l,t,"utf-8"),l}async writeAtomic(e,t){let s=y.dirname(e),o=y.join(s,`.${y.basename(e)}.tmp.${Date.now()}`);try{await b.mkdir(s,{recursive:!0});let n=JSON.stringify(t,null,2);await b.writeFile(o,n,"utf-8");let r=await b.open(o,"r+");await r.sync(),await r.close(),await b.rename(o,e)}catch(n){try{await b.unlink(o)}catch{}throw n}}static expandPath(e){return e.startsWith("~")?y.join(te.homedir(),e.slice(1)):e}};import{promises as p,constants as N}from"fs";import d from"path";import se from"os";var R=class{constructor(e){this.config=e}merger=new P;async install(){if(this.config.dryRun)return this.dryRunInstall();try{let e=this.getInstallationPaths();await this.createInstallationDirectory(e.installDir);let t=await this.copyFiles(e.installDir);await this.setPermissions(e.installDir);let s=await this.installHooks(e);return await this.createManifest(e.installDir,t,e.settingsPath,s.hooksAdded),{success:!0,installedTo:e.installDir,settingsPath:e.settingsPath,backupPath:s.backupPath,hooksAdded:s.hooksAdded,message:`Successfully installed cctoast-wsl to ${e.installDir}`}}catch(e){return{success:!1,installedTo:"",settingsPath:"",hooksAdded:[],message:`Installation failed: ${e.message}`}}}async dryRunInstall(){let e=this.getInstallationPaths(),t=this.generateHookCommands(e.installDir),s=[];this.config.notificationHook&&s.push("notification"),this.config.stopHook&&s.push("stop");let o=["DRY RUN - No changes would be made:",`Install directory: ${e.installDir}`,`Settings file: ${e.settingsPath}`,`Hooks to add: ${s.join(", ")}`,"Hook commands:",...Object.entries(t).map(([n,r])=>`  ${n}: ${r}`)].join(`
`);return{success:!0,installedTo:e.installDir,settingsPath:e.settingsPath,hooksAdded:s,message:o}}getInstallationPaths(){if(this.config.global||!this.config.local){let t=se.homedir(),s=d.join(t,".claude","cctoast-wsl"),o=d.join(t,".claude","settings.json");return{installDir:s,settingsPath:o,scope:"global"}}else{let t=process.cwd(),s=d.join(t,".claude","cctoast-wsl"),o=this.config.sync?d.join(t,".claude","settings.json"):d.join(t,".claude","settings.local.json");return{installDir:s,settingsPath:o,scope:"local"}}}async createInstallationDirectory(e){await p.mkdir(e,{recursive:!0}),await p.mkdir(d.join(e,"assets"),{recursive:!0})}async copyFiles(e){let t=[],s=d.join(process.cwd(),"scripts","show-toast.sh"),o=d.join(e,"show-toast.sh");await p.copyFile(s,o),t.push("show-toast.sh");let n=d.join(process.cwd(),"assets","claude.png"),r=d.join(e,"assets","claude.png");try{await p.copyFile(n,r),t.push("assets/claude.png")}catch{console.warn("Warning: Could not copy claude.png icon")}return t}async setPermissions(e){let t=d.join(e,"show-toast.sh");await p.chmod(t,320)}async installHooks(e){let t=this.generateHookCommands(e.installDir),s={hooks:{}},o=[];this.config.notificationHook&&(s.hooks.notification=[t.notification],o.push("notification")),this.config.stopHook&&(s.hooks.stop=[t.stop],o.push("stop"));let n=await this.merger.mergeFile(e.settingsPath,s,{deduplicateArrays:!0,preserveOrder:!0,createBackup:!0});return{hooksAdded:o,backupPath:n.backupPath,changed:n.changed}}generateHookCommands(e){let t=d.join(e,"show-toast.sh");return{notification:`${t} --notification-hook`,stop:`${t} --stop-hook`}}async createManifest(e,t,s,o){let n={version:"1.0.0",installedAt:new Date().toISOString(),config:this.config,files:t,settingsPath:s,hooksInstalled:o},r=d.join(e,"install-manifest.json");await p.writeFile(r,JSON.stringify(n,null,2),"utf-8")}async uninstall(){try{let e=this.getInstallationPaths(),t=d.join(e.installDir,"install-manifest.json"),s=null;try{let n=await p.readFile(t,"utf-8");s=JSON.parse(n)}catch{}let o=await this.removeHooks(e,s);return await p.rm(e.installDir,{recursive:!0,force:!0}),{success:!0,installedTo:e.installDir,settingsPath:e.settingsPath,hooksAdded:[],message:`Successfully uninstalled cctoast-wsl from ${e.installDir}. Removed hooks: ${o.join(", ")}`}}catch(e){return{success:!1,installedTo:"",settingsPath:"",hooksAdded:[],message:`Uninstall failed: ${e.message}`}}}async removeHooks(e,t){let s=[];try{let o=await p.readFile(e.settingsPath,"utf-8"),n=await this.merger.parseJsonc(o);if(!n.hooks)return s;let r=this.generateHookCommands(e.installDir);for(let[l,i]of Object.entries(r)){let m=n.hooks[l];if(m){let f=m.filter(O=>O!==i);f.length!==m.length&&(n.hooks[l]=f.length>0?f:void 0,s.push(l))}}await this.merger.mergeFile(e.settingsPath,n,{createBackup:!0})}catch{}return s}async isInstalled(){let e=this.getInstallationPaths();try{return await p.access(e.installDir,N.F_OK),await p.access(d.join(e.installDir,"show-toast.sh"),N.F_OK),!0}catch{return!1}}};var re=ie(new URL(".",import.meta.url)),le=ae(re,"..","package.json"),M=JSON.parse(ne(le,"utf8")),h={SUCCESS:0,USER_ABORT:1,DEPENDENCY_FAILURE:2,IO_ERROR:3};function ce(){let a=new oe;return a.name("cctoast-wsl").description("Secure, zero-admin utility for Windows toast notifications from WSL via Claude Code hooks").version(M.version,"-v, --version","Display version number"),a.option("-g, --global","Install for user to ~/.claude/... (default)").option("-l, --local","Install for project to .claude/...").addHelpText("after",`
Scope Options:
  Only one of --global or --local can be specified`),a.option("--notification","Include Notification hook (default)",!0).option("--no-notification","Exclude Notification hook").option("--stop","Include Stop hook (default)",!0).option("--no-stop","Exclude Stop hook"),a.option("--sync","When local, modify tracked settings.json instead of settings.local.json (not recommended for teams due to Windows-only nature of hooks)",!1),a.option("-p, --print-instructions","Show usage instructions and exit").option("--json","Machine-readable JSON output",!1).option("-n, --dry-run","Preview changes without writing files").option("-f, --force","Bypass failed dependency checks (except BurntToast)").option("-q, --quiet","Suppress interactive prompts for CI environments"),a.option("--uninstall","Remove cctoast-wsl installation"),a}function ue(a){!a.global&&!a.local&&(a.global=!0),a.global&&a.local&&(console.error("Error: --global and --local flags cannot be used together"),u.exit(h.USER_ABORT)),!a.notification&&!a.stop&&(console.error("Error: At least one hook (--notification or --stop) must be enabled"),u.exit(h.USER_ABORT)),a.sync&&!a.local&&console.error("Warning: --sync flag only applies to local installations")}function me(){console.log(`
cctoast-wsl v${M.version} - Usage Instructions

INSTALLATION:
  npx @claude/cctoast-wsl                    # Global install with defaults
  npx @claude/cctoast-wsl --local           # Local project install
  npx @claude/cctoast-wsl --dry-run         # Preview changes

EXAMPLES:
  npx @claude/cctoast-wsl --global --notification --stop
  npx @claude/cctoast-wsl --local --sync --no-stop
  npx @claude/cctoast-wsl --uninstall --global

HOOK USAGE:
  After installation, Claude Code will automatically trigger toast notifications:
  - Notification hook: Shows when Claude is waiting for input
  - Stop hook: Shows when Claude completes a task

MANUAL TESTING:
  ~/.claude/cctoast-wsl/show-toast.sh --notification-hook
  ~/.claude/cctoast-wsl/show-toast.sh --stop-hook

For complete documentation: https://github.com/claudes-world/cctoast-wsl
`),u.exit(h.SUCCESS)}function de(){return u.stdin.isTTY&&u.stdout.isTTY}function k(){c.cancel("Operation cancelled by user"),u.exit(h.USER_ABORT)}async function he(){c.intro("\u{1F35E} cctoast-wsl Installation");let a=await c.select({message:"Choose installation scope:",options:[{value:"global",label:"Global",hint:"\u2605 Recommended - Install to ~/.claude/"},{value:"local",label:"Local",hint:"Install to current project .claude/"}]});c.isCancel(a)&&k();let e=a,t=await c.multiselect({message:"Select hooks to enable:",options:[{value:"notification",label:"Notification hook",hint:"Shows toast when Claude is waiting for input"},{value:"stop",label:"Stop hook",hint:"Shows toast when Claude completes a task"}],initialValues:["notification","stop"],required:!0});c.isCancel(t)&&k();let s=!1;if(e==="local"){let i=await c.confirm({message:"Modify tracked settings.json instead of settings.local.json?",initialValue:!1});c.isCancel(i)&&k(),s=i}let o=t,n=[`Scope: ${e}`,`Hooks: ${o.join(", ")}`,...e==="local"?[`Sync: ${s?"yes":"no"}`]:[]];c.log.info(`Configuration summary:
${n.map(i=>`  \u2022 ${i}`).join(`
`)}`);let r="";e==="global"?r=`
Hooks for ${o.map(i=>i.charAt(0).toUpperCase()+i.slice(1)).join(" and ")} will be added to your global settings at ~/.claude/settings.json.
The cctoast-wsl tool will install the necessary scripts and configuration for Windows toast notifications, available to all WSL sessions for your user.`:e==="local"&&(s?r=`
Hooks for ${o.map(i=>i.charAt(0).toUpperCase()+i.slice(1)).join(" and ")} will be added to your project's tracked settings at ./.claude/settings.json.
This will update the main project settings (recommended only if your team is Windows-only).`:r=`
Hooks for ${o.map(i=>i.charAt(0).toUpperCase()+i.slice(1)).join(" and ")} will be added to your local-only settings at ./.claude/settings.local.json.
This keeps Windows-specific configuration out of version control, ideal for cross-platform teams.`,r+=`
The cctoast-wsl tool will install the necessary scripts and configuration for toast notifications in this project.`),r&&c.log.message(r);let l=await c.confirm({message:"Proceed with installation?",initialValue:!0});return(c.isCancel(l)||!l)&&k(),c.outro("Ready to install! \u{1F389}"),{global:e==="global",local:e==="local",notification:o.includes("notification"),stop:o.includes("stop"),sync:s,printInstructions:!1,json:!1,dryRun:!1,force:!1,quiet:!1,uninstall:!1}}function pe(){u.on("SIGINT",()=>{c.cancel(`
Operation cancelled by user`),u.exit(h.USER_ABORT)}),u.on("SIGTERM",()=>{c.cancel(`
Operation terminated`),u.exit(h.USER_ABORT)})}async function fe(a){let e=c.spinner();e.start("Checking system dependencies..."),a.quiet||console.log(`\u{1F50D} Checking system dependencies...
`);let s=await new w(a.force).checkAll(),o=s.filter(l=>!l.passed&&l.fatal),n=s.filter(l=>!l.passed&&!l.fatal),r=s.filter(l=>l.passed);if(a.quiet||(r.forEach(l=>{c.log.message(`${l.message}`,{symbol:U.default.cyan("\u2714")})}),n.forEach(l=>{console.log(`\u26A0\uFE0F  ${l.message}`),l.remedy&&console.log(`   \u{1F4A1} ${l.remedy}`)})),o.length>0){if(a.quiet||(console.log(`
\u274C Fatal dependency checks failed:
`),o.forEach(i=>{console.log(`   \u2022 ${i.message}`),i.remedy&&console.log(`     Fix: ${i.remedy}`)})),o.find(i=>i.name==="burnttoast-module")&&!a.quiet){let i=new v;try{console.log(`
\u{1F916} Auto-installation available for BurntToast module`);let m=await c.confirm({message:"Would you like to automatically install BurntToast PowerShell module?",initialValue:!0});if(c.isCancel(m)&&k(),m)if(await i.install(),await i.verify()){if(console.log("\u2705 BurntToast module installed and verified successfully"),o.filter(O=>O.name!=="burnttoast-module").length===0){console.log(`
\u{1F389} All dependency checks now pass!`);return}}else console.log("\u274C BurntToast installation verification failed")}catch(m){console.log(`\u274C Auto-installation failed: ${m instanceof Error?m.message:m}`)}}(!a.force||o.some(i=>i.name==="burnttoast-module"))&&(console.log(`
\u{1F4A1} Use --force to bypass non-fatal checks, but BurntToast is required`),u.exit(h.DEPENDENCY_FAILURE))}!a.quiet&&n.length===0&&o.length===0&&console.log(`
\u{1F389} All dependency checks passed!`),e.stop()}function ge(a){return["--global","-g","--local","-l","--no-notification","--no-stop","--sync","--json","--dry-run","-n","--force","-f","--quiet","-q","--uninstall"].some(t=>a.includes(t))}async function be(){try{pe();let a=ce();a.parse();let e=a.opts();if(e.printInstructions){me();return}if(!e.quiet&&de()&&!ge(u.argv)?e=await he():ue(e),e.json){let n=await new w(e.force).checkAll(),r={action:e.uninstall?"uninstall":"install",scope:e.local?"local":"global",hooks:{notification:e.notification,stop:e.stop},settings:{sync:e.sync,dryRun:e.dryRun,force:e.force,quiet:e.quiet},dependencies:{timestamp:new Date().toISOString(),results:n.map(i=>({name:i.name,passed:i.passed,fatal:i.fatal,message:i.message,remedy:i.remedy})),summary:{total:n.length,passed:n.filter(i=>i.passed).length,failed:n.filter(i=>!i.passed).length,fatal:n.filter(i=>!i.passed&&i.fatal).length,warnings:n.filter(i=>!i.passed&&!i.fatal).length}}};console.log(JSON.stringify(r,null,2)),n.filter(i=>!i.passed&&i.fatal).length>0&&!e.force&&u.exit(h.DEPENDENCY_FAILURE)}else await fe(e);e.dryRun&&!e.json&&console.log(`
\u{1F4CB} DRY RUN MODE - No files will be modified`);let s=new R({global:e.global||!e.local,local:e.local,notificationHook:e.notification,stopHook:e.stop,sync:e.sync,dryRun:e.dryRun});try{let o;if(e.uninstall?o=await s.uninstall():o=await s.install(),e.json){let n={action:e.uninstall?"uninstall":"install",scope:e.local?"local":"global",hooks:{notification:e.notification,stop:e.stop},settings:{sync:e.sync,dryRun:e.dryRun,force:e.force,quiet:e.quiet},installation:{success:o.success,installedTo:o.installedTo,settingsPath:o.settingsPath,backupPath:o.backupPath,hooksAdded:o.hooksAdded,message:o.message}};console.log(JSON.stringify(n,null,2))}else o.success?(console.log(`
${o.message}`),o.backupPath&&console.log(`\u{1F4C1} Backup created: ${o.backupPath}`),o.hooksAdded.length>0&&console.log(`\u{1FA9D} Hooks added: ${o.hooksAdded.join(", ")}`)):(console.error(`
\u274C ${o.message}`),u.exit(h.IO_ERROR))}catch(o){let n=`Installation failed: ${o instanceof Error?o.message:o}`;e.json?console.log(JSON.stringify({error:n},null,2)):console.error(`
\u274C ${n}`),u.exit(h.IO_ERROR)}}catch(a){console.error("Unexpected error:",a instanceof Error?a.message:a),u.exit(h.IO_ERROR)}}import.meta.url===`file://${u.argv[1]}`&&be().catch(a=>{console.error("Fatal error:",a),u.exit(h.IO_ERROR)});export{h as ExitCodes,ce as initializeCLI,be as main,ue as validateFlags};
