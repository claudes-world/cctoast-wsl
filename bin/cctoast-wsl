#!/usr/bin/env node


// src/cli.ts
import { Command } from "commander";
import process from "node:process";
import { readFileSync } from "node:fs";
import { join } from "node:path";
import { fileURLToPath } from "node:url";
import { intro, outro, select, multiselect, confirm, isCancel, cancel, log } from "@clack/prompts";
var __dirname = fileURLToPath(new URL(".", import.meta.url));
var packagePath = join(__dirname, "..", "package.json");
var packageJson = JSON.parse(readFileSync(packagePath, "utf8"));
var ExitCodes = {
  SUCCESS: 0,
  USER_ABORT: 1,
  DEPENDENCY_FAILURE: 2,
  IO_ERROR: 3
};
function initializeCLI() {
  const program = new Command();
  program.name("cctoast-wsl").description("Secure, zero-admin utility for Windows toast notifications from WSL via Claude Code hooks").version(packageJson.version, "-v, --version", "Display version number");
  program.option("-g, --global", "Install to ~/.claude/... (default)").option("-l, --local", "Install to .claude/...").addHelpText("after", "\nScope Options:\n  Only one of --global or --local can be specified");
  program.option("--notification", "Include Notification hook (default)", true).option("--no-notification", "Exclude Notification hook").option("--stop", "Include Stop hook (default)", true).option("--no-stop", "Exclude Stop hook");
  program.option("--sync", "When local, modify tracked settings.json instead of settings.local.json", false);
  program.option("-p, --print-instructions", "Show usage instructions and exit").option("--json", "Machine-readable JSON output", false).option("-n, --dry-run", "Preview changes without writing files").option("-f, --force", "Bypass failed dependency checks (except BurntToast)").option("-q, --quiet", "Suppress interactive prompts for CI environments");
  program.option("--uninstall", "Remove cctoast-wsl installation");
  return program;
}
function validateFlags(options) {
  if (!options.global && !options.local) {
    options.global = true;
  }
  if (options.global && options.local) {
    console.error("Error: --global and --local flags cannot be used together");
    process.exit(ExitCodes.USER_ABORT);
  }
  if (!options.notification && !options.stop) {
    console.error("Error: At least one hook (--notification or --stop) must be enabled");
    process.exit(ExitCodes.USER_ABORT);
  }
  if (options.sync && !options.local) {
    console.error("Warning: --sync flag only applies to local installations");
  }
}
function handlePrintInstructions() {
  console.log(`
cctoast-wsl v${packageJson.version} - Usage Instructions

INSTALLATION:
  npx @claude/cctoast-wsl                    # Global install with defaults
  npx @claude/cctoast-wsl --local           # Local project install
  npx @claude/cctoast-wsl --dry-run         # Preview changes

EXAMPLES:
  npx @claude/cctoast-wsl --global --notification --stop
  npx @claude/cctoast-wsl --local --sync --no-stop
  npx @claude/cctoast-wsl --uninstall --global

HOOK USAGE:
  After installation, Claude Code will automatically trigger toast notifications:
  - Notification hook: Shows when Claude is waiting for input
  - Stop hook: Shows when Claude completes a task

MANUAL TESTING:
  ~/.claude/cctoast-wsl/show-toast.sh --notification-hook
  ~/.claude/cctoast-wsl/show-toast.sh --stop-hook

For complete documentation: https://github.com/claudes-world/cctoast-wsl
`);
  process.exit(ExitCodes.SUCCESS);
}
function formatOutput(data, useJson) {
  if (useJson) {
    console.log(JSON.stringify(data, null, 2));
  } else {
    console.log("Installation completed successfully");
  }
}
function isInteractive() {
  return process.stdin.isTTY && process.stdout.isTTY;
}
function handleCancel() {
  cancel("Operation cancelled by user");
  process.exit(ExitCodes.USER_ABORT);
}
async function runInteractiveMode() {
  intro("\u{1F35E} cctoast-wsl Installation");
  const scope = await select({
    message: "Choose installation scope:",
    options: [
      {
        value: "global",
        label: "Global",
        hint: "Install to ~/.claude/ (recommended)"
      },
      {
        value: "local",
        label: "Local",
        hint: "Install to current project .claude/"
      }
    ]
  });
  if (isCancel(scope)) {
    handleCancel();
  }
  const scopeValue = scope;
  const hooks = await multiselect({
    message: "Select hooks to enable:",
    options: [
      {
        value: "notification",
        label: "Notification hook",
        hint: "Shows toast when Claude is waiting for input"
      },
      {
        value: "stop",
        label: "Stop hook",
        hint: "Shows toast when Claude completes a task"
      }
    ],
    initialValues: ["notification", "stop"],
    required: true
  });
  if (isCancel(hooks)) {
    handleCancel();
  }
  let sync = false;
  if (scopeValue === "local") {
    const syncResult = await confirm({
      message: "Modify tracked settings.json instead of settings.local.json?",
      initialValue: false
    });
    if (isCancel(syncResult)) {
      handleCancel();
    }
    sync = syncResult;
  }
  const hooksList = hooks;
  const summary = [
    `Scope: ${scopeValue}`,
    `Hooks: ${hooksList.join(", ")}`,
    ...scopeValue === "local" ? [`Sync: ${sync ? "yes" : "no"}`] : []
  ];
  log.info(`Configuration summary:
${summary.map((item) => `  \u2022 ${item}`).join("\n")}`);
  const proceed = await confirm({
    message: "Proceed with installation?",
    initialValue: true
  });
  if (isCancel(proceed) || !proceed) {
    handleCancel();
  }
  outro("Ready to install! \u{1F389}");
  return {
    global: scopeValue === "global",
    local: scopeValue === "local",
    notification: hooksList.includes("notification"),
    stop: hooksList.includes("stop"),
    sync,
    printInstructions: false,
    json: false,
    dryRun: false,
    force: false,
    quiet: false,
    uninstall: false
  };
}
function setupSignalHandlers() {
  process.on("SIGINT", () => {
    cancel("\nOperation cancelled by user");
    process.exit(ExitCodes.USER_ABORT);
  });
  process.on("SIGTERM", () => {
    cancel("\nOperation terminated");
    process.exit(ExitCodes.USER_ABORT);
  });
}
function hasExplicitFlags(argv) {
  const flagsToCheck = [
    "--global",
    "-g",
    "--local",
    "-l",
    "--no-notification",
    "--no-stop",
    "--sync",
    "--json",
    "--dry-run",
    "-n",
    "--force",
    "-f",
    "--quiet",
    "-q",
    "--uninstall"
  ];
  return flagsToCheck.some((flag) => argv.includes(flag));
}
async function main() {
  try {
    setupSignalHandlers();
    const program = initializeCLI();
    program.parse();
    let options = program.opts();
    if (options.printInstructions) {
      handlePrintInstructions();
      return;
    }
    const shouldUseInteractive = !options.quiet && isInteractive() && !hasExplicitFlags(process.argv);
    if (shouldUseInteractive) {
      options = await runInteractiveMode();
    } else {
      validateFlags(options);
    }
    const result = {
      action: options.uninstall ? "uninstall" : "install",
      scope: options.local ? "local" : "global",
      hooks: {
        notification: options.notification,
        stop: options.stop
      },
      settings: {
        sync: options.sync,
        dryRun: options.dryRun,
        force: options.force,
        quiet: options.quiet
      }
    };
    if (options.dryRun) {
      console.log("DRY RUN MODE - No files will be modified\n");
    }
    if (!shouldUseInteractive) {
      formatOutput(result, options.json);
    }
    if (!options.json && !shouldUseInteractive) {
      console.log("\nCLI Framework implemented successfully!");
      console.log("Installation logic will be added in Milestone 4");
    }
  } catch (error) {
    console.error("Unexpected error:", error instanceof Error ? error.message : error);
    process.exit(ExitCodes.IO_ERROR);
  }
}
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(ExitCodes.IO_ERROR);
  });
}
export {
  ExitCodes,
  initializeCLI,
  main,
  validateFlags
};
//# sourceMappingURL=cctoast-wsl.map
